Attribute VB_Name = "Optimisation"
Option Explicit

Const MAX_DOUBLE As Double = 1.79769313486231E+308


' whether to output slicing scores
Public Const dSLICE_SCORES = 1

' we use these globals to store the data we're using for the
' in-worksheet optimiser
Private globalTimes As Collection
Private globalBearings As Collection


' work out an optimal slicing for this leg
' times: the bearing times
' bearings: the bearings
' zigBuffer: the time period we allow for a turn
' optimiseThreshold: when optimisation is stable
' sliceDelta: how much better the slices have to be
Public Function sliceThisLeg(thisLeg As leg, _
    zigBuffer As Double, optimiseThreshold As Double, sliceDelta As Double, _
    diag As Integer) As Legs
    
    Dim results As Legs
    Set results = New Legs
    
    ' ok, find the overall score
    Dim overallScore As Double
    overallScore = optimiseThis(thisLeg, optimiseThreshold)
    
    If (diag And Optimisation.dSLICE_SCORES) Then
        Debug.Print "Overall leg score:" & overallScore
    End If
    
    ' and now work through the slices
    Dim tLen As Integer
    tLen = thisLeg.times.Count
    Dim ctr As Integer
    
    Dim bestSoFar As Double
    bestSoFar = MAX_DOUBLE
    
    For ctr = 1 To tLen
        ' get the time at this point
        Dim tNow As Double
        tNow = thisLeg.times.Item(ctr)
    
        ' ok, slice it at this point
        Dim theLegs As Legs
        Set theLegs = SliceIntoLegs(thisLeg, tNow, zigBuffer)
        
        ' right, get the score for the two slices
        Dim beforeScore As Double, afterScore As Double
        
        beforeScore = optimiseThis(theLegs.Items(1), optimiseThreshold)
        afterScore = optimiseThis(theLegs.Items(2), optimiseThreshold)
                   
        If (diag And Optimisation.dSLICE_SCORES) Then
            Debug.Print "Before score:" & beforeScore
            Debug.Print "After score:" & afterScore
        End If
                   
        ' find the leg lengths (ready to normalise)
        Dim totalCuts As Integer
        Dim beforeLen As Integer
        Dim afterLen As Integer
        beforeLen = theLegs.Items(1).times.Count
        afterLen = theLegs.Items(2).times.Count
        totalCuts = beforeLen + afterLen

        ' did we get any answers?
        If (beforeScore > 0) And (afterScore > 0) Then
            ' ok, normalise their scores
            beforeScore = beforeScore * beforeLen / totalCuts
            afterScore = afterScore * afterLen / totalCuts
            
            ' and calculate the result
            Dim result As Double
            result = beforeScore + afterScore
            
            ' is it better?
            If (result < bestSoFar) Then
            
                If (diag And Optimisation.dSLICE_SCORES) Then
                    Debug.Print "new optimal score, turning at:" & tNow & " is:" & result
                    Debug.Print "After score:" & afterScore
                End If

                bestSoFar = result
                
                ' and remember the legs
                Set results = theLegs
            End If
        End If
        
    Next ctr
    
    ' ok, compare the scores
    If (bestSoFar - overallScore > sliceDelta) Then
        ' good enough. keep the results
    Else
        ' no, not good enough. forget them
        Set results = New Legs
        
        Debug.Print ("Slices not better:" & (bestSoFar - sliceDelta))
    End If
    
    Set sliceThisLeg = results
    
End Function


Private Function optimiseThis(thisLeg As leg, threshold As Double) As Double

    Dim result As Double
    result = 0
    
    ' check we have a minimum number of values
    If (thisLeg.times.Count > 1) Then
    
        ' switch off screen updates
        Application.ScreenUpdating = False
    
        With Worksheets("OptimiseBPQ")
    
        ' put the datasets into global space (so the forecast function can see them)
        Set globalTimes = thisLeg.times
        Set globalBearings = thisLeg.bearings
    
        ' ok, setup the optimiser
        SolverReset
        
        ' set the threshold for acceptance
        
        ' set the allowable step size
        SolverOptions precision:=0.001
        SolverOK SetCell:=Range("B6"), _
           MaxMinVal:=2, _
           ByChange:=Range("B3:B5")
        
        ' run the solver
        SolverSolve UserFinish:=True
        
        ' get the result out of the box
        result = Range("B6")
        
        End With
        
        ' and switch updatse back on
        Application.ScreenUpdating = True
        
    End If
    
    ' store the result
    optimiseThis = result
    
End Function


Public Function calculateScore(B As Double, P As Double, Q As Double) As Double
    Dim runningTotal
    runningTotal = 0
        
    Dim times As Collection
    Dim bearings As Collection
    
    If (True) Then
    
        ' do we have global data?
        If (globalTimes Is Nothing) Then
        
            Debug.Print "creating globs"
            ' create some data
            Dim data As Collection
            Set data = Tests.collateTheseLegs
            Dim track As leg
            Set track = data.Item(1)
            Set globalTimes = track.times
            Set globalBearings = track.bearings
        End If
        
        Set times = globalTimes
        Set bearings = globalBearings
        
        Dim startTime
        startTime = globalTimes.Item(1)
    
        ' ok, loop through the times
        Dim counter As Integer
        
        For counter = 1 To globalTimes.Count
            Dim thisTime
            thisTime = globalTimes.Item(counter)
            
            Dim elapsed As Double
            elapsed = thisTime - startTime
            
            Dim thisBearing
            thisBearing = globalBearings.Item(counter)
            
            If elapsed > 0 Then
                ' ok, calculate it
                Dim forecast
                forecast = forecastValue(elapsed, B, P, Q)
                
                Dim score
                score = forecast - thisBearing
                score = score * score
                
                runningTotal = runningTotal + score
                
            End If
            
        Next counter
        
        If (runningTotal > 0) Then
            runningTotal = Sqr(runningTotal)
        End If
        
    End If
    
    calculateScore = runningTotal
    
End Function

Private Function forecastValue(elapsedTime, B As Double, P As Double, Q As Double)
    Dim dx, dy
    dx = Cos(B) + Q * elapsedTime
    dy = Sin(B) + P * elapsedTime
    forecastValue = Excel.WorksheetFunction.Atan2(dy, dx)
End Function

Sub clearDebugConsole()
    Dim i As Integer
    For i = 0 To 4
         Debug.Print ""
    Next i

End Sub



